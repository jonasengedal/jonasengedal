# Make it Work/Right/Fast

The principle **"Make It Work, Make It Right, Make It Fast"** by Kent Beck provides a pragmatic approach to software development. It emphasizes the importance of focusing on functionality, correctness, and performance in stages, rather than trying to achieve all three at once. This principle is widely used in agile development and Test-Driven Development (TDD) practices.

Most of this page was generated by ChatGPT.

## References

- [Make it Work. Make it Right. Make it Fast. By Weekly Dev Tips](https://weeklydevtips.com/episodes/006)

## 1. Make It Work

**Goal**: Ensure the software achieves its intended functionality.

- **Focus**: Deliver a working solution that satisfies the basic requirements.
- **Actions**:
  - Implement the simplest code to solve the problem.
  - Prioritize functionality over code elegance or optimization.
  - Write minimal tests to confirm the core functionality works.
- **Outcome**: You have a working prototype or solution that demonstrates the basic concept or feature.

**Why It's Important**:
- Early feedback: Ensures stakeholders can see tangible results quickly.
- Reduces risk: Verifies that the problem can be solved before investing in optimization or refactoring.

---

### **2. Make It Right**
**Goal**: Improve the code to ensure correctness, readability, and maintainability.

- **Focus**: Refactor the working solution to make the code clean, modular, and reliable.
- **Actions**:
  - Follow best practices and design principles (e.g., SOLID).
  - Eliminate technical debt and code smells.
  - Write comprehensive tests to cover edge cases and ensure robustness.
- **Outcome**: You have well-structured, high-quality code that is easier to maintain and extend.

**Why It's Important**:
- Code longevity: Clean, correct code is less prone to bugs and easier to adapt to changing requirements.
- Team productivity: Readable and modular code allows other developers to understand and collaborate effectively.

---

### **3. Make It Fast**
**Goal**: Optimize the solution for performance and efficiency.

- **Focus**: Improve the code’s performance without compromising correctness or maintainability.
- **Actions**:
  - Profile the application to identify bottlenecks.
  - Optimize algorithms and data structures.
  - Apply caching or other performance-enhancing techniques where necessary.
- **Outcome**: You have a performant application that retains its functional correctness and maintainability.

**Why It's Important**:
- Avoid premature optimization: Optimizing too early can lead to complex code that’s hard to understand and maintain.
- Focused improvements: Ensures time and effort are spent on areas that have the most impact on performance.

---

### **Why This Principle Works**
1. **Incremental Progress**: By tackling one priority at a time, it avoids overwhelming the development process.
2. **Risk Mitigation**: Ensures the core functionality works before investing time in polish or speed.
3. **Adaptability**: Allows you to adjust to changing requirements after delivering a working version.

---

### **Example: Building a Login Feature**
1. **Make It Work**:
   - Implement basic functionality: a user can enter credentials and log in if valid.
   - Use placeholder authentication logic (e.g., hardcoded username/password).

2. **Make It Right**:
   - Replace placeholder logic with proper user authentication (e.g., database lookup, password hashing).
   - Refactor the code for modularity (e.g., separate authentication logic into its own class or service).
   - Write tests for valid, invalid, and edge cases (e.g., SQL injection prevention).

3. **Make It Fast**:
   - Optimize database queries (e.g., add indexing).
   - Cache user credentials where applicable.
   - Reduce response time by minimizing network calls.

---

### **Conclusion**
Kent Beck's principle is a guide to balancing functionality, quality, and performance in software development. By working in stages, developers can ensure the application meets user needs, is maintainable, and performs well—without falling into the traps of premature optimization or overengineering.